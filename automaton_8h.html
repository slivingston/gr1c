<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gr1c: automaton.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="gr1cdoc.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gr1c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">automaton.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Routines for working with a strategy, as a finite automaton.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;<a class="el" href="common_8h.html">common.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ptree_8h.html">ptree.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structanode__t.html">anode_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy automaton nodes.  <a href="structanode__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2f380c751f91c6f27c8b8ca8c34c4ac2"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DotDumpFlags.html#ga2f380c751f91c6f27c8b8ca8c34c4ac2">DOT_AUT_ALL</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga2f380c751f91c6f27c8b8ca8c34c4ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show all variables with values. <br /></td></tr>
<tr class="separator:ga2f380c751f91c6f27c8b8ca8c34c4ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43296551a53d0f526ed5224d1f407e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DotDumpFlags.html#gaf43296551a53d0f526ed5224d1f407e4">DOT_AUT_ATTRIB</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:gaf43296551a53d0f526ed5224d1f407e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show node attributes.  <a href="group__DotDumpFlags.html#gaf43296551a53d0f526ed5224d1f407e4">More...</a><br /></td></tr>
<tr class="separator:gaf43296551a53d0f526ed5224d1f407e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a4e537f3f20d76ed8d98247da74d75"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DotDumpFlags.html#gae2a4e537f3f20d76ed8d98247da74d75">DOT_AUT_BINARY</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gae2a4e537f3f20d76ed8d98247da74d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume variables have Boolean domains, and only label nodes with those that are True. <br /></td></tr>
<tr class="separator:gae2a4e537f3f20d76ed8d98247da74d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga274bae2c00790303c7690b97ab7ae104"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DotDumpFlags.html#ga274bae2c00790303c7690b97ab7ae104">DOT_AUT_EDGEINPUT</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga274bae2c00790303c7690b97ab7ae104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show environment variables on edges. <br /></td></tr>
<tr class="separator:ga274bae2c00790303c7690b97ab7ae104"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aebf26a051f8f3e1bb94ac6d046ff4efa"><td class="memItemLeft" align="right" valign="top"><a id="aebf26a051f8f3e1bb94ac6d046ff4efa"></a>
typedef struct <a class="el" href="structanode__t.html">anode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aebf26a051f8f3e1bb94ac6d046ff4efa">anode_t</a></td></tr>
<tr class="memdesc:aebf26a051f8f3e1bb94ac6d046ff4efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy automaton nodes. <br /></td></tr>
<tr class="separator:aebf26a051f8f3e1bb94ac6d046ff4efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa61aa0ed3574d98e39ecb49e308b737a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aa61aa0ed3574d98e39ecb49e308b737a">anode_index</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structanode__t.html">anode_t</a> *node)</td></tr>
<tr class="separator:aa61aa0ed3574d98e39ecb49e308b737a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19117fcc49ec68e9ded2509805151220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a19117fcc49ec68e9ded2509805151220">append_anode_trans</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, vartype *state, int state_len, int next_mode, vartype *next_state)</td></tr>
<tr class="separator:a19117fcc49ec68e9ded2509805151220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7280119d68f6970fc7146b20833ffd63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a7280119d68f6970fc7146b20833ffd63">aut_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int state_len, FILE *fp)</td></tr>
<tr class="separator:a7280119d68f6970fc7146b20833ffd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1ee46d08bdd897ae13d09e50771523"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aab1ee46d08bdd897ae13d09e50771523">aut_aut_dumpver</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int state_len, FILE *fp, int version)</td></tr>
<tr class="separator:aab1ee46d08bdd897ae13d09e50771523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88038233d4f53e8d4746c8d1bd12064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aa88038233d4f53e8d4746c8d1bd12064">aut_aut_load</a> (int state_len, FILE *fp)</td></tr>
<tr class="separator:aa88038233d4f53e8d4746c8d1bd12064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067126ca7da0a5fde4f540fda603b32a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a067126ca7da0a5fde4f540fda603b32a">aut_aut_loadver</a> (int state_len, FILE *fp, int *version)</td></tr>
<tr class="separator:a067126ca7da0a5fde4f540fda603b32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed4487bcde54e28bc052775df303abb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a9ed4487bcde54e28bc052775df303abb">aut_compact_nonbool</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, char *name, int maxval)</td></tr>
<tr class="separator:a9ed4487bcde54e28bc052775df303abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ce2f635a2a35a4ed1e50f1e01dd54b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#ad9ce2f635a2a35a4ed1e50f1e01dd54b">aut_expand_bool</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, <a class="el" href="structptree__t.html">ptree_t</a> *nonbool_var_list)</td></tr>
<tr class="separator:ad9ce2f635a2a35a4ed1e50f1e01dd54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda7c3c8f7ffdfaa59b6455bc54e90cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#adda7c3c8f7ffdfaa59b6455bc54e90cb">aut_prune_deadends</a> (<a class="el" href="structanode__t.html">anode_t</a> *head)</td></tr>
<tr class="separator:adda7c3c8f7ffdfaa59b6455bc54e90cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cb2e6e6ecbabd19b75c00ecef27278"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#ad5cb2e6e6ecbabd19b75c00ecef27278">aut_size</a> (<a class="el" href="structanode__t.html">anode_t</a> *head)</td></tr>
<tr class="separator:ad5cb2e6e6ecbabd19b75c00ecef27278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa891331c0240fd76c11421f50e2653e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aa891331c0240fd76c11421f50e2653e3">build_anode_trans</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, vartype *state, int state_len, int next_mode, vartype **next_states, int next_len)</td></tr>
<tr class="separator:aa891331c0240fd76c11421f50e2653e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2058a2959949782553b2f4bf3302fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a1c2058a2959949782553b2f4bf3302fa">delete_anode</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structanode__t.html">anode_t</a> *target)</td></tr>
<tr class="separator:a1c2058a2959949782553b2f4bf3302fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6003bf5e6d68756a2ff99dfd86d1b2f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a6003bf5e6d68756a2ff99dfd86d1b2f4">delete_aut</a> (<a class="el" href="structanode__t.html">anode_t</a> *head)</td></tr>
<tr class="separator:a6003bf5e6d68756a2ff99dfd86d1b2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa042707aac1b8820ab74ae4272068284"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aa042707aac1b8820ab74ae4272068284">dot_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, unsigned char format_flags, FILE *fp)</td></tr>
<tr class="separator:aa042707aac1b8820ab74ae4272068284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0921457452ddc98b3fcf28ec8dd9a9c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a0921457452ddc98b3fcf28ec8dd9a9c5">find_anode</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, vartype *state, int state_len)</td></tr>
<tr class="separator:a0921457452ddc98b3fcf28ec8dd9a9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6e4b0af816787fd51d57884a58fa93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a5c6e4b0af816787fd51d57884a58fa93">find_anode_index</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, vartype *state, int state_len)</td></tr>
<tr class="separator:a5c6e4b0af816787fd51d57884a58fa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea5d34a7e37ffc8e17a717db52e41e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a0ea5d34a7e37ffc8e17a717db52e41e5">forward_modereach</a> (<a class="el" href="structanode__t.html">anode_t</a> *node, int mode, vartype **N, int N_len, int magic_mode, int state_len)</td></tr>
<tr class="separator:a0ea5d34a7e37ffc8e17a717db52e41e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703c9ee45cce2fa6963c08c6e47ae36d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a703c9ee45cce2fa6963c08c6e47ae36d">forward_prune</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structanode__t.html">anode_t</a> **U, int U_len)</td></tr>
<tr class="separator:a703c9ee45cce2fa6963c08c6e47ae36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f4ed14e45b2acfbc744d1311a5378f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a37f4ed14e45b2acfbc744d1311a5378f">insert_anode</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, int rgrad, bool initial, vartype *state, int state_len)</td></tr>
<tr class="separator:a37f4ed14e45b2acfbc744d1311a5378f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8e5e021f2e1f64687936957440de5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#acf8e5e021f2e1f64687936957440de5e">json_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, FILE *fp)</td></tr>
<tr class="separator:acf8e5e021f2e1f64687936957440de5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0084e8abf09eed89cd7aa2acc03e15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#acb0084e8abf09eed89cd7aa2acc03e15">list_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int state_len, FILE *fp)</td></tr>
<tr class="separator:acb0084e8abf09eed89cd7aa2acc03e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6e451c56cf9ed34916afa860221490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aea6e451c56cf9ed34916afa860221490">pop_anode</a> (<a class="el" href="structanode__t.html">anode_t</a> *head)</td></tr>
<tr class="separator:aea6e451c56cf9ed34916afa860221490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69834ddebd4ca217886025375182f19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#af69834ddebd4ca217886025375182f19">replace_anode_trans</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structanode__t.html">anode_t</a> *old, <a class="el" href="structanode__t.html">anode_t</a> *new)</td></tr>
<tr class="separator:af69834ddebd4ca217886025375182f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaca330310b1d2aad82d6e3eab2ce81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a8aaca330310b1d2aad82d6e3eab2ce81">spin_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, <a class="el" href="structptree__t.html">ptree_t</a> *env_init, <a class="el" href="structptree__t.html">ptree_t</a> *sys_init, <a class="el" href="structptree__t.html">ptree_t</a> **env_trans_array, int et_array_len, <a class="el" href="structptree__t.html">ptree_t</a> **sys_trans_array, int st_array_len, <a class="el" href="structptree__t.html">ptree_t</a> **env_goals, int num_env_goals, <a class="el" href="structptree__t.html">ptree_t</a> **sys_goals, int num_sys_goals, FILE *fp, FILE *formula_fp)</td></tr>
<tr class="separator:a8aaca330310b1d2aad82d6e3eab2ce81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ce928c0c55d6482bc6b6a0e7135240"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a67ce928c0c55d6482bc6b6a0e7135240">tulip0_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, FILE *fp)</td></tr>
<tr class="separator:a67ce928c0c55d6482bc6b6a0e7135240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad135af09f28e95ad66d501893df662d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#ad135af09f28e95ad66d501893df662d6">tulip_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, FILE *fp)</td></tr>
<tr class="separator:ad135af09f28e95ad66d501893df662d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Routines for working with a strategy, as a finite automaton. </p>
<p>Note that the length of the state vector in each node is not stored anywhere in this data structure. It is assumed to be positive and constant for a particular automaton (strategy).</p>
<p>SCL; 2012-2015 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa61aa0ed3574d98e39ecb49e308b737a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61aa0ed3574d98e39ecb49e308b737a">&#9670;&nbsp;</a></span>anode_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int anode_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the position of the given node, or -1 if not found. 0-based indexing. </p>

</div>
</div>
<a id="a19117fcc49ec68e9ded2509805151220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19117fcc49ec68e9ded2509805151220">&#9670;&nbsp;</a></span>append_anode_trans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* append_anode_trans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype *&#160;</td>
          <td class="paramname"><em>next_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append transition to array for the first node with given state and mode.</p>
<p>This function does not check for duplicate outgoing edges.</p>
<dl class="section return"><dt>Returns</dt><dd>head on success, NULL on error. </dd></dl>

</div>
</div>
<a id="a7280119d68f6970fc7146b20833ffd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7280119d68f6970fc7146b20833ffd63">&#9670;&nbsp;</a></span>aut_aut_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aut_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump strategy using the current version of the "gr1c automaton" file format. Read <a href="md_formats.html">external_notes</a> for details. If fp = NULL, then write to stdout. </p>

</div>
</div>
<a id="aab1ee46d08bdd897ae13d09e50771523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1ee46d08bdd897ae13d09e50771523">&#9670;&nbsp;</a></span>aut_aut_dumpver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aut_aut_dumpver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump strategy using the specified version of the "gr1c automaton" file format. This function is wrapped by <a class="el" href="automaton_8h.html#a7280119d68f6970fc7146b20833ffd63">aut_aut_dump()</a>. Return 0 on success. If the given version number is not supported, then return -1. </p>

</div>
</div>
<a id="aa88038233d4f53e8d4746c8d1bd12064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88038233d4f53e8d4746c8d1bd12064">&#9670;&nbsp;</a></span>aut_aut_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* aut_aut_load </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Legacy wrapper for <a class="el" href="automaton_8h.html#aa88038233d4f53e8d4746c8d1bd12064">aut_aut_load()</a>. Equivalent to calling <a class="el" href="automaton_8h.html#a067126ca7da0a5fde4f540fda603b32a">aut_aut_loadver()</a> with version == NULL </p>

</div>
</div>
<a id="a067126ca7da0a5fde4f540fda603b32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067126ca7da0a5fde4f540fda603b32a">&#9670;&nbsp;</a></span>aut_aut_loadver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* aut_aut_loadver </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load strategy given in "gr1c automaton" format from file fp. Read <a href="md_formats.html">external_notes</a> for details. If fp = NULL, then read from stdin. Return resulting head pointer, or NULL if error. If version is not NULL, then the detected format version number is placed in *version.</p>
<p>Note that attempting to load a gr1c automaton file for a version that includes fields not present in this build of gr1c results in a warning message while all supported fields are used. If expected fields are missing (e.g., no rgrad number is available), then the appropriate "unset" indicator is set to each such field; typically this is -1, check the definition of <a class="el" href="structanode__t.html" title="Strategy automaton nodes. ">anode_t</a> for details. </p>

</div>
</div>
<a id="a9ed4487bcde54e28bc052775df303abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed4487bcde54e28bc052775df303abb">&#9670;&nbsp;</a></span>aut_compact_nonbool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aut_compact_nonbool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert binary-expanded form of a variable back into nonboolean. The domain of the variable is [0,maxval], and to indicate this the value field is set to maxval in the resulting (merged) variable entry (in evar_list or svar_list). Returns the new state vector length, or -1 on error. </p>

</div>
</div>
<a id="ad9ce2f635a2a35a4ed1e50f1e01dd54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ce2f635a2a35a4ed1e50f1e01dd54b">&#9670;&nbsp;</a></span>aut_expand_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aut_expand_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>nonbool_var_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverse operation of <a class="el" href="automaton_8h.html#a9ed4487bcde54e28bc052775df303abb">aut_compact_nonbool()</a>. Return zero on success, nonzero on error. </p>

</div>
</div>
<a id="adda7c3c8f7ffdfaa59b6455bc54e90cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda7c3c8f7ffdfaa59b6455bc54e90cb">&#9670;&nbsp;</a></span>aut_prune_deadends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* aut_prune_deadends </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return (possibly new) head pointer. </p>

</div>
</div>
<a id="ad5cb2e6e6ecbabd19b75c00ecef27278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5cb2e6e6ecbabd19b75c00ecef27278">&#9670;&nbsp;</a></span>aut_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aut_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get number of nodes in given automaton. </p>

</div>
</div>
<a id="aa891331c0240fd76c11421f50e2653e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa891331c0240fd76c11421f50e2653e3">&#9670;&nbsp;</a></span>build_anode_trans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* build_anode_trans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype **&#160;</td>
          <td class="paramname"><em>next_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build the transition array for the first node with given state and mode.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This function will be removed soon. In practice, it is more robust and general to populate the transition array directly. To find nodes of the appropriate next mode (as this function would), use <a class="el" href="automaton_8h.html#a0921457452ddc98b3fcf28ec8dd9a9c5">find_anode()</a>.</dd></dl>
<p>next_states is an array of state vectors, with length next_len, used to build transitions for this node. All of these states have mode next_mode, and the actual transitions are to the first nodes found with these states and mode.</p>
<p>If the base node already has a transition array, then it is not replaced until the new array has been successfully built. (That is, if error, the original node should be unaffected.)</p>
<p>Return given head on success, NULL if one of the needed nodes is not found. </p>

</div>
</div>
<a id="a1c2058a2959949782553b2f4bf3302fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2058a2959949782553b2f4bf3302fa">&#9670;&nbsp;</a></span>delete_anode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* delete_anode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete target node from strategy automaton.</p>
<p>Note that any references to <code>target</code> in transition arrays of other nodes are not modified by this function. If you want to change or delete any such pointers to <code>target</code>, use <a class="el" href="automaton_8h.html#af69834ddebd4ca217886025375182f19">replace_anode_trans()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>pointer to the strategy automaton to be modified.</td></tr>
    <tr><td class="paramname">target</td><td>node to be deleted. The associated state vector and transition array are freed. If <code>target</code> is not found, then return value is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(possibly new) head pointer. If <code>head</code> or <code>target</code> is NULL or if <code>target</code> is not found, then return NULL. If head=target and there is only one node, then return NULL (because the only node is deleted, there can be no head pointer). </dd></dl>

</div>
</div>
<a id="a6003bf5e6d68756a2ff99dfd86d1b2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6003bf5e6d68756a2ff99dfd86d1b2f4">&#9670;&nbsp;</a></span>delete_aut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_aut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete entire automaton pointed to by given head.</p>
<p>Essentially, traverses node list and frees them and their member data. At completion, the given head pointer is no longer valid. Invoking with NULL pointer causes return with no error. </p>

</div>
</div>
<a id="aa042707aac1b8820ab74ae4272068284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa042707aac1b8820ab74ae4272068284">&#9670;&nbsp;</a></span>dot_aut_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dot_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>format_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump DOT file describing the automaton (strategy). The appearance can be configured using <a class="el" href="group__DotDumpFlags.html">format flags for dot_aut_dump</a>. Also read comments for <a class="el" href="automaton_8h.html#ad135af09f28e95ad66d501893df662d6">tulip_aut_dump()</a>. </p>

</div>
</div>
<a id="a0921457452ddc98b3fcf28ec8dd9a9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0921457452ddc98b3fcf28ec8dd9a9c5">&#9670;&nbsp;</a></span>find_anode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* find_anode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return pointer to the first node with given state and mode, or NULL if not found. </p>

</div>
</div>
<a id="a5c6e4b0af816787fd51d57884a58fa93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6e4b0af816787fd51d57884a58fa93">&#9670;&nbsp;</a></span>find_anode_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int find_anode_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the position of the first node with given state and mode, or -1 if not found. 0-based indexing. </p>

</div>
</div>
<a id="a0ea5d34a7e37ffc8e17a717db52e41e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea5d34a7e37ffc8e17a717db52e41e5">&#9670;&nbsp;</a></span>forward_modereach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int forward_modereach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype **&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>magic_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute forward reachable set from given node in automaton, restricting attention to nodes with state in N and goal mode of mode, and setting the mode field of each reached node to magic_mode. Return zero on success, nonzero on error. </p>

</div>
</div>
<a id="a703c9ee45cce2fa6963c08c6e47ae36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703c9ee45cce2fa6963c08c6e47ae36d">&#9670;&nbsp;</a></span>forward_prune()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* forward_prune </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> **&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>U_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete nodes in U that are not reachable in the graph from outside U, and then repeat. Nodes marked as initial are ignored; such nodes are supposed to satisfy initial conditions, i.e., from which execution is allowed to begin and hence do not need ingoing edges.</p>
<p>The given array U is altered and freed during execution of <a class="el" href="automaton_8h.html#a703c9ee45cce2fa6963c08c6e47ae36d">forward_prune()</a>, so the caller should not attempt to use it afterward.</p>
<p>U may be redundant, i.e., the implementation is tolerant to U having multiple pointers to the same node.</p>
<p>Return (possibly new) head pointer, or NULL on error. </p>

</div>
</div>
<a id="a37f4ed14e45b2acfbc744d1311a5378f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f4ed14e45b2acfbc744d1311a5378f">&#9670;&nbsp;</a></span>insert_anode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* insert_anode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rgrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert node at the front of the given node list. If given head is NULL, a new list will be created.</p>
<p>Return new head on success, NULL on error. </p>

</div>
</div>
<a id="acf8e5e021f2e1f64687936957440de5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8e5e021f2e1f64687936957440de5e">&#9670;&nbsp;</a></span>json_aut_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int json_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump strategy using the current version of the gr1c-JSON file format. Consult <a href="md_formats.html">external_notes</a> for details. </p>

</div>
</div>
<a id="acb0084e8abf09eed89cd7aa2acc03e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0084e8abf09eed89cd7aa2acc03e15">&#9670;&nbsp;</a></span>list_aut_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump list of nodes; mostly useful for debugging. If fp = NULL, then write to stdout. The basic format is </p><pre class="fragment">i [(init)] : S - m - r - [t0 t1 ...]
</pre><p>where i is the node ID (used only as a means to uniquely refer to nodes), S is the state at that node as comma-separated values, m is the goal mode, r is the reach annotation value, and [t0 t1 ...] is the list of IDs of nodes reachable in one step. The node ID is followed by "(init)" if the initial field is marked True. </p>

</div>
</div>
<a id="aea6e451c56cf9ed34916afa860221490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6e451c56cf9ed34916afa860221490">&#9670;&nbsp;</a></span>pop_anode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* pop_anode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete topmost (head) node from list. Return pointer to new head. </p>

</div>
</div>
<a id="af69834ddebd4ca217886025375182f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69834ddebd4ca217886025375182f19">&#9670;&nbsp;</a></span>replace_anode_trans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void replace_anode_trans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace all occurrences of "old" with "new" in transition arrays. If "new" is NULL, then the transitions into "old" are deleted and all dependent transition array lengths are decremented. </p>

</div>
</div>
<a id="a8aaca330310b1d2aad82d6e3eab2ce81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aaca330310b1d2aad82d6e3eab2ce81">&#9670;&nbsp;</a></span>spin_aut_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spin_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>env_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>sys_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> **&#160;</td>
          <td class="paramname"><em>env_trans_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>et_array_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> **&#160;</td>
          <td class="paramname"><em>sys_trans_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>st_array_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> **&#160;</td>
          <td class="paramname"><em>env_goals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_env_goals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> **&#160;</td>
          <td class="paramname"><em>sys_goals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_sys_goals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>formula_fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump strategy as Spin Promela model.</p>
<p>Assumptions:</p><ul>
<li>no more than 10000 environment goals;</li>
<li>no more than 10000 system goals;</li>
<li>none of the variables has the following names: checketrans, checkstrans, pmlfault, envinit, envtrans, envgoal0, envgoal1, ... sysinit, systrans, sysgoal0, sysgoal1, ...</li>
</ul>
<p>An LTL formula that can be used to decide whether the strategy realizes the GR(1) specification is included in the comments near the top of the generated Spin Promela model.</p>
<p>Example instructions for model checking are provided in doc/verification.md.</p>
<p>If fp = NULL, then write to stdout.</p>
<p>If fp != NULL, then formula_fp is the file in which to print the LTL formula, or stdout if formula_fp = NULL. Note that this is a copy of the LTL formula that is included in the Promela model, which is described above.</p>
<p>If fp = formula_fp (i.e., the same file pointer), then do not print the LTL formula to formula_fp.</p>
<p>Return nonzero if error. </p>

</div>
</div>
<a id="a67ce928c0c55d6482bc6b6a0e7135240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ce928c0c55d6482bc6b6a0e7135240">&#9670;&nbsp;</a></span>tulip0_aut_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tulip0_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump using tulipcon version 0. DEPRECATED! Please use <a class="el" href="automaton_8h.html#ad135af09f28e95ad66d501893df662d6">tulip_aut_dump()</a> instead. <a class="el" href="automaton_8h.html#a67ce928c0c55d6482bc6b6a0e7135240">tulip0_aut_dump()</a> is provided only for legacy code and will soon be removed. </p>

</div>
</div>
<a id="ad135af09f28e95ad66d501893df662d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad135af09f28e95ad66d501893df662d6">&#9670;&nbsp;</a></span>tulip_aut_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tulip_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump tulipcon XML file describing the automaton (strategy). Variable names are obtained from evar_list and svar_list, in which the combined order is assumed to match that of the state vector in each automaton node.</p>
<p>For each node, the goal mode and reach annotation value are placed in a &lt;anno&gt; tag in that order.</p>
<p>If fp = NULL, then write to stdout. Return nonzero if error. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
