<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gr1c: ptree.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="gr1cdoc.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">gr1c
   &#160;<span id="projectnumber">0.12.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ptree.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Routines for working with a GR(1) formula parse tree.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;cudd.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptree__t.html">ptree_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse tree nodes.  <a href="structptree__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga49f63ec3a101ce59ef013166fee5cdef"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FORMULA_SYNTAX_GR1C</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga49f63ec3a101ce59ef013166fee5cdef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17557ea213115474a7c954ec5a9096b3"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FORMULA_SYNTAX_SPIN</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga17557ea213115474a7c954ec5a9096b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9dc9b513bea52c22365977321cc11a2"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_AND</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:gab9dc9b513bea52c22365977321cc11a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177747356bffa4845d930faf0e4c1cfd"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_CONSTANT</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ga177747356bffa4845d930faf0e4c1cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6349ed07090e8057ed1daea2f15f26e8"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_EMPTY</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga6349ed07090e8057ed1daea2f15f26e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac33d88561c7a1bea76d5e370d78c3992"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_EQUALS</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:gac33d88561c7a1bea76d5e370d78c3992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03faab32bb7f386c5fbf4c3d1653c945"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_EQUIV</b>&#160;&#160;&#160;9</td></tr>
<tr class="separator:ga03faab32bb7f386c5fbf4c3d1653c945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58c3985c32dd5efc187e060950959f54"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_GE</b>&#160;&#160;&#160;13  /* greater than or equal to, i.e., &quot;&gt;=&quot; */</td></tr>
<tr class="separator:ga58c3985c32dd5efc187e060950959f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga758711b493bd603eec78bfbd794cf2a0"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_GT</b>&#160;&#160;&#160;11  /* greater than, i.e., &quot;&gt;&quot; */</td></tr>
<tr class="separator:ga758711b493bd603eec78bfbd794cf2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f51a52c333c31b9d3b2ae0b76668f0d"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_IMPLIES</b>&#160;&#160;&#160;7</td></tr>
<tr class="separator:ga8f51a52c333c31b9d3b2ae0b76668f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7b21e52b2a45990fcc517928c28bfb"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LE</b>&#160;&#160;&#160;12  /* less than or equal to, i.e., &quot;&lt;=&quot; */</td></tr>
<tr class="separator:ga7e7b21e52b2a45990fcc517928c28bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace6718bd23170139c7ace1b4615a963c"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LT</b>&#160;&#160;&#160;10  /* less than, i.e., &quot;&lt;&quot; */</td></tr>
<tr class="separator:gace6718bd23170139c7ace1b4615a963c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecba5ac3abe523f3bd5517fef3a5be70"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_NEG</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:gaecba5ac3abe523f3bd5517fef3a5be70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54cdb075307d81ea220e835cdf12fde8"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_NEXT_VARIABLE</b>&#160;&#160;&#160;2  /* primed variable */</td></tr>
<tr class="separator:ga54cdb075307d81ea220e835cdf12fde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54f83ea7d9bd4fa6956eba2516005291"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_NOTEQ</b>&#160;&#160;&#160;14  /* not equals */</td></tr>
<tr class="separator:ga54f83ea7d9bd4fa6956eba2516005291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7dcb8931b363d69e7ed74e5a3a4f65"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_OR</b>&#160;&#160;&#160;6</td></tr>
<tr class="separator:ga5e7dcb8931b363d69e7ed74e5a3a4f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae470b6c1a72050d46b0240c6e28335f4"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_VARIABLE</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:gae470b6c1a72050d46b0240c6e28335f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aeffb11122e9c865945360a7038ab859d"><td class="memItemLeft" align="right" valign="top"><a id="aeffb11122e9c865945360a7038ab859d"></a>
typedef struct <a class="el" href="structptree__t.html">ptree_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#aeffb11122e9c865945360a7038ab859d">ptree_t</a></td></tr>
<tr class="memdesc:aeffb11122e9c865945360a7038ab859d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse tree nodes. <br /></td></tr>
<tr class="separator:aeffb11122e9c865945360a7038ab859d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afec3ab9b5f6928970bf419384d05a7da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#afec3ab9b5f6928970bf419384d05a7da">append_list_item</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, int type, char *name, int value)</td></tr>
<tr class="separator:afec3ab9b5f6928970bf419384d05a7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accaba06e25428c972a57bca6785b1922"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#accaba06e25428c972a57bca6785b1922">check_vars</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *var_list, <a class="el" href="structptree__t.html">ptree_t</a> *nextvar_list)</td></tr>
<tr class="separator:accaba06e25428c972a57bca6785b1922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97dca87ce7dfca53df3e6c28d688d7c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a97dca87ce7dfca53df3e6c28d688d7c3">copy_ptree</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head)</td></tr>
<tr class="separator:a97dca87ce7dfca53df3e6c28d688d7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e85d3f26e47440f53bf401b2625a83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a09e85d3f26e47440f53bf401b2625a83">delete_tree</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head)</td></tr>
<tr class="separator:a09e85d3f26e47440f53bf401b2625a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b9a8f9772d6d48a5fb69c7418f6906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#af7b9a8f9772d6d48a5fb69c7418f6906">expand_to_bool</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, char *name, int maxval)</td></tr>
<tr class="separator:af7b9a8f9772d6d48a5fb69c7418f6906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4aad181edffc721e3c12e4d5b5ccdfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#ac4aad181edffc721e3c12e4d5b5ccdfc">find_list_item</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, int type, char *name, int value)</td></tr>
<tr class="separator:ac4aad181edffc721e3c12e4d5b5ccdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af21185cb2323bfb4582c6ddacc4469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a9af21185cb2323bfb4582c6ddacc4469">get_list_item</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, int index)</td></tr>
<tr class="separator:a9af21185cb2323bfb4582c6ddacc4469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac029417fbed404f2ce560fffa51beaf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#ac029417fbed404f2ce560fffa51beaf7">init_ptree</a> (int type, char *name, int value)</td></tr>
<tr class="separator:ac029417fbed404f2ce560fffa51beaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab667656ec259d42be9768c401458805b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#ab667656ec259d42be9768c401458805b">inorder_trav</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, void(*node_fn)(<a class="el" href="structptree__t.html">ptree_t</a> *, void *), void *arg)</td></tr>
<tr class="separator:ab667656ec259d42be9768c401458805b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc2f16adc9a33681af5e4c879482c4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a1cc2f16adc9a33681af5e4c879482c4c">max_tree_value</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head)</td></tr>
<tr class="separator:a1cc2f16adc9a33681af5e4c879482c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bfe48b3b350e90785d382a7ea2918d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a13bfe48b3b350e90785d382a7ea2918d">merge_ptrees</a> (<a class="el" href="structptree__t.html">ptree_t</a> **heads, int len, int type)</td></tr>
<tr class="separator:a13bfe48b3b350e90785d382a7ea2918d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4b88da22f7aa227961eb8052b0b358"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#aed4b88da22f7aa227961eb8052b0b358">min_tree_value</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head)</td></tr>
<tr class="separator:aed4b88da22f7aa227961eb8052b0b358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b61854e1e9d3b3b16d83dd37b7ab80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a93b61854e1e9d3b3b16d83dd37b7ab80">print_formula</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, FILE *fp, unsigned char format_flags)</td></tr>
<tr class="separator:a93b61854e1e9d3b3b16d83dd37b7ab80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ae1907d506910fb09d6c065649a1c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a22ae1907d506910fb09d6c065649a1c4">print_node</a> (<a class="el" href="structptree__t.html">ptree_t</a> *node, FILE *fp)</td></tr>
<tr class="separator:a22ae1907d506910fb09d6c065649a1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca77712054f6a4107bc3f0154d174ff"><td class="memItemLeft" align="right" valign="top">DdNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a5ca77712054f6a4107bc3f0154d174ff">ptree_BDD</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *var_list, DdManager *manager)</td></tr>
<tr class="separator:a5ca77712054f6a4107bc3f0154d174ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ee9c6d601fdfcb42181e24f1a59505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a43ee9c6d601fdfcb42181e24f1a59505">pusht_operator</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, int type)</td></tr>
<tr class="separator:a43ee9c6d601fdfcb42181e24f1a59505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91871715a40802631f35fcc755240e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a91871715a40802631f35fcc755240e49">pusht_terminal</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, int type, char *name, int value)</td></tr>
<tr class="separator:a91871715a40802631f35fcc755240e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2031cfade02e94a3a7a38d7d593890d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a2031cfade02e94a3a7a38d7d593890d6">remove_list_item</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, int index)</td></tr>
<tr class="separator:a2031cfade02e94a3a7a38d7d593890d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cc0b8b8aa96dcf8b31e9dbf62fb95c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a91cc0b8b8aa96dcf8b31e9dbf62fb95c">rmax_tree_value</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, char *name)</td></tr>
<tr class="separator:a91cc0b8b8aa96dcf8b31e9dbf62fb95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18e9cef7171d4560c86bfbdeb7aa38f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#aa18e9cef7171d4560c86bfbdeb7aa38f">rmin_tree_value</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, char *name)</td></tr>
<tr class="separator:aa18e9cef7171d4560c86bfbdeb7aa38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8632c58da19ad428dabd36e8c5325c1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a8632c58da19ad428dabd36e8c5325c1e">tree_dot_dump</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, char *filename)</td></tr>
<tr class="separator:a8632c58da19ad428dabd36e8c5325c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30878b132f25dc77a40f9a62e98729bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a30878b132f25dc77a40f9a62e98729bb">tree_size</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head)</td></tr>
<tr class="separator:a30878b132f25dc77a40f9a62e98729bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45bda40e09c6e412d64b38bc7a57dd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#af45bda40e09c6e412d64b38bc7a57dd6">unreach_expanded_bool</a> (char *name, int lower, int upper, int type)</td></tr>
<tr class="separator:af45bda40e09c6e412d64b38bc7a57dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f0cbc31bd000f3cc7d54f9025d308f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#ae7f0cbc31bd000f3cc7d54f9025d308f">var_to_bool</a> (char *name, int maxval)</td></tr>
<tr class="separator:ae7f0cbc31bd000f3cc7d54f9025d308f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Routines for working with a GR(1) formula parse tree. </p>
<p>To avoid defining another basic data structure, we may effectively obtain a linked list by making a binary tree with no right children (or more generally, a tree in which each node has at most one child). Functions intended specifically to support this use case include "list" in their names.</p>
<p>For functions concerning tree nodes, any arguments that are not applicable to the given type are ignored.</p>
<p>SCL; 2012-2015 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="afec3ab9b5f6928970bf419384d05a7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec3ab9b5f6928970bf419384d05a7da">&#9670;&nbsp;</a></span>append_list_item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* append_list_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return pointer to new item (which is of course accessible via given root node). If argument head is NULL, then behave exactly as <a class="el" href="ptree_8h.html#ac029417fbed404f2ce560fffa51beaf7">init_ptree()</a> (and thus, a new tree root node is returned). </p>

</div>
</div>
<a id="accaba06e25428c972a57bca6785b1922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accaba06e25428c972a57bca6785b1922">&#9670;&nbsp;</a></span>check_vars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* check_vars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>var_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>nextvar_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify that every variable (resp., primed variable) in given parse tree is contained in var_list (resp., nextvar_list). Return NULL if successfully verified; else, return a pointer to a string of a violating variable, which the caller is expected to free. </p>

</div>
</div>
<a id="a97dca87ce7dfca53df3e6c28d688d7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97dca87ce7dfca53df3e6c28d688d7c3">&#9670;&nbsp;</a></span>copy_ptree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* copy_ptree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return (deep) copy of given ptree. Return NULL on error. </p>

</div>
</div>
<a id="a09e85d3f26e47440f53bf401b2625a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e85d3f26e47440f53bf401b2625a83">&#9670;&nbsp;</a></span>delete_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete tree with given root node. </p>

</div>
</div>
<a id="af7b9a8f9772d6d48a5fb69c7418f6906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b9a8f9772d6d48a5fb69c7418f6906">&#9670;&nbsp;</a></span>expand_to_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* expand_to_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand all occurrences of name (a variable) in formula described by the tree head, replacing by Boolean variables as would be found by <a class="el" href="ptree_8h.html#ae7f0cbc31bd000f3cc7d54f9025d308f">var_to_bool()</a>. Changes are made in-place.</p>
<p>Return the (possibly new) head pointer, or NULL if error. </p>

</div>
</div>
<a id="ac4aad181edffc721e3c12e4d5b5ccdfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4aad181edffc721e3c12e4d5b5ccdfc">&#9670;&nbsp;</a></span>find_list_item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int find_list_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return index (0-base) to first match in list, or -1 if not found.</p>
<p>If head is NULL, then return -1. </p>

</div>
</div>
<a id="a9af21185cb2323bfb4582c6ddacc4469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af21185cb2323bfb4582c6ddacc4469">&#9670;&nbsp;</a></span>get_list_item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* get_list_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>0-based indexing. An index of -1 refers to the last item in the list. Return pointer to the node, or NULL on error. </p>

</div>
</div>
<a id="ac029417fbed404f2ce560fffa51beaf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac029417fbed404f2ce560fffa51beaf7">&#9670;&nbsp;</a></span>init_ptree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* init_ptree </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create root node with given type.</p>
<p>The arguments correspond with members of the <a class="el" href="structptree__t.html" title="Parse tree nodes. ">ptree_t</a> structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>one of the <a class="el" href="group__PTreeNodeTypes.html">parse tree node types</a>.</td></tr>
    <tr><td class="paramname">name</td><td>string of variable name, or NULL; if <code>name</code> is not NULL, then an internal copy is created of the string to which <code>name</code> is a pointer.</td></tr>
    <tr><td class="paramname">value</td><td>meaning and whether this is used depends on <code>type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the new tree, or NULL if error. </dd></dl>

</div>
</div>
<a id="ab667656ec259d42be9768c401458805b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab667656ec259d42be9768c401458805b">&#9670;&nbsp;</a></span>inorder_trav()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inorder_trav </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structptree__t.html">ptree_t</a> *, void *)&#160;</td>
          <td class="paramname"><em>node_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Traverse the tree in-order, calling *node_fn at each node and passing it arg. </p>

</div>
</div>
<a id="a1cc2f16adc9a33681af5e4c879482c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc2f16adc9a33681af5e4c879482c4c">&#9670;&nbsp;</a></span>max_tree_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int max_tree_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximum value among PT_CONSTANT nodes in given tree.</p>
<p>Also read documentation for <a class="el" href="ptree_8h.html#aed4b88da22f7aa227961eb8052b0b358">min_tree_value()</a>. </p>

</div>
</div>
<a id="a13bfe48b3b350e90785d382a7ea2918d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bfe48b3b350e90785d382a7ea2918d">&#9670;&nbsp;</a></span>merge_ptrees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* merge_ptrees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> **&#160;</td>
          <td class="paramname"><em>heads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new tree in which all of the given trees are included by the specified binary operator. len is the length of heads. Return pointer to the new tree root, or NULL on error. N.B., the given trees are <em>pointed to</em> by the new tree, i.e, their roots become nodes in the new tree, and therefore you generally should <em>not</em> try to free the originals (but can discard the old heads pointers). </p>

</div>
</div>
<a id="aed4b88da22f7aa227961eb8052b0b358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4b88da22f7aa227961eb8052b0b358">&#9670;&nbsp;</a></span>min_tree_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int min_tree_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the minimum value among PT_CONSTANT nodes in given tree.</p>
<p>N.B., -9999 is used as a special indicator value to allow <a class="el" href="ptree_8h.html#aed4b88da22f7aa227961eb8052b0b358">min_tree_value()</a> to work on the tree recursively.</p>
<p>If head is NULL or there are not any PT_CONSTANT nodes, then the output is undefined. </p>

</div>
</div>
<a id="a93b61854e1e9d3b3b16d83dd37b7ab80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b61854e1e9d3b3b16d83dd37b7ab80">&#9670;&nbsp;</a></span>print_formula()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_formula </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>format_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If f is NULL, then use stdout. Cf table of <a class="el" href="group__PTreeFormulaSyntax.html">Formula syntax in which to print a ptree.</a>. </p>

</div>
</div>
<a id="a22ae1907d506910fb09d6c065649a1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ae1907d506910fb09d6c065649a1c4">&#9670;&nbsp;</a></span>print_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If f is NULL, then use stdout. </p>

</div>
</div>
<a id="a5ca77712054f6a4107bc3f0154d174ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca77712054f6a4107bc3f0154d174ff">&#9670;&nbsp;</a></span>ptree_BDD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DdNode* ptree_BDD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>var_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DdManager *&#160;</td>
          <td class="paramname"><em>manager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate BDD corresponding to given parse tree. var_list is the linked list of variable names to refer to; ordering in var_list determines index in the BDD. Non-Boolean variables and equality are not supported. fn should be NULL, unless you wish to initialize with a non-constant-True function.</p>
<p>Any primed variables (type of PT_NEXT_VARIABLE) will be given an index corresponding to unprimed variables but offset by the total number of variables (length of list var_list). </p>

</div>
</div>
<a id="a43ee9c6d601fdfcb42181e24f1a59505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ee9c6d601fdfcb42181e24f1a59505">&#9670;&nbsp;</a></span>pusht_operator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* pusht_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push unary or binary operator into top of tree. (Behavior is like reverse Polish notation.) Return the new head. </p>

</div>
</div>
<a id="a91871715a40802631f35fcc755240e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91871715a40802631f35fcc755240e49">&#9670;&nbsp;</a></span>pusht_terminal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* pusht_terminal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push variable or constant into top of tree.</p>
<p>(Behavior is like reverse Polish notation.) If <code>name</code> is not NULL and if <code>type</code> implies the relevance of <code>name</code> (cf. <a class="el" href="structptree__t.html" title="Parse tree nodes. ">ptree_t</a> and <a class="el" href="group__PTreeNodeTypes.html">parse tree node types</a>), then an internal copy is created. Return the new head. </p>

</div>
</div>
<a id="a2031cfade02e94a3a7a38d7d593890d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2031cfade02e94a3a7a38d7d593890d6">&#9670;&nbsp;</a></span>remove_list_item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* remove_list_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>0-based indexing. An index of -1 refers to the last item in the list. Return pointer to parent of removed node if non-root, or to item with original index of 1 if root.</p>
<p>If head is NULL (i.e., tree is empty), then print a warning and return NULL. If index is outside of possible range, then print warning and return NULL. </p>

</div>
</div>
<a id="a91cc0b8b8aa96dcf8b31e9dbf62fb95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cc0b8b8aa96dcf8b31e9dbf62fb95c">&#9670;&nbsp;</a></span>rmax_tree_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rmax_tree_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="ptree_8h.html#a91cc0b8b8aa96dcf8b31e9dbf62fb95c">rmax_tree_value()</a> but find maximum among v=k expressions. </p>

</div>
</div>
<a id="aa18e9cef7171d4560c86bfbdeb7aa38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18e9cef7171d4560c86bfbdeb7aa38f">&#9670;&nbsp;</a></span>rmin_tree_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rmin_tree_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the minimum value among expressions of the form v = k.</p>
<p>Among all expressions in the tree of the form v = k, where v is a variable or primed variable with the given name, and where k is a constant value, find the smallest such k. Note that an expression in the tree has meaning as the corresponding subformula that would be obtained by flattening the parse tree into a formula.</p>
<p>If head is NULL, or if no equality expressions of this form are found, then the return value is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>(string) name of the variable or primed variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8632c58da19ad428dabd36e8c5325c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8632c58da19ad428dabd36e8c5325c1e">&#9670;&nbsp;</a></span>tree_dot_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tree_dot_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate Graphviz DOT file depicting the parse tree. Return 0 on success, -1 on error. </p>

</div>
</div>
<a id="a30878b132f25dc77a40f9a62e98729bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30878b132f25dc77a40f9a62e98729bb">&#9670;&nbsp;</a></span>tree_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tree_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return number of nodes in tree. </p>

</div>
</div>
<a id="af45bda40e09c6e412d64b38bc7a57dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45bda40e09c6e412d64b38bc7a57dd6">&#9670;&nbsp;</a></span>unreach_expanded_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* unreach_expanded_bool </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create tree describing unreachable values of a nonboolean-expanded-to-boolean variable. E.g., this can be used to handle "don't care" values that appear as a side-effect of conversion to a bitvector. The formula corresponding to the tree is of the form !(v = k1) &amp; !(v = k2) &amp; ... where k1 &lt; k2 &lt; ... are values in the range [lower, upper] (inclusive). type should be one PT_VARIABLE or PT_NEXT_VARIABLE. </p>

</div>
</div>
<a id="ae7f0cbc31bd000f3cc7d54f9025d308f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f0cbc31bd000f3cc7d54f9025d308f">&#9670;&nbsp;</a></span>var_to_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* var_to_bool </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>name is a variable with domain {0,...,maxval}, where we assume that maxval is at least 2. Return a list of variables in order of increasing bit index, e.g., invoking with a variable named "foo" and maxval=2 causes a list to be returned of the form foo0,foo1.</p>
<p>The maximum length of the resulting variable names, i.e., names after appending bit indices, is 1024. (This is fixed as an internal constant.)</p>
<p>Return NULL on error. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
